---
export interface Props {
  title: string;
  author: string;
  thumbnail: string;
  videoUrl?: string;
  fullVideoUrl?: string;
  category?: string;
  slug?: string;
}

const { title, author, thumbnail, videoUrl, fullVideoUrl, category, slug } = Astro.props;
---

<a href={slug ? `/videos/${slug}` : '#'} class="video-card group cursor-pointer block" data-video-url={videoUrl}>
  <!-- Video Container -->
  <div class="relative overflow-hidden aspect-video bg-black">
    <!-- TV Noise Loading Canvas -->
    <canvas
      class="video-loading-canvas absolute inset-0 w-full h-full"
    ></canvas>

    <!-- Video Element -->
    {videoUrl ? (
      <video
        class="video-element w-full h-full object-cover opacity-0 transition-opacity duration-500"
        muted
        loop
        playsinline
        preload="none"
        data-src={videoUrl}
      >
        <source data-src={videoUrl} type="video/mp4" />
      </video>
    ) : (
      <!-- Fallback image if no video URL -->
      <img
        src={thumbnail}
        alt={title}
        class="w-full h-full object-cover"
        loading="lazy"
      />
    )}
    
    <!-- Video Overlay (subtle) -->
    <div class="absolute inset-0 bg-black/5 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
  </div>
  
  <!-- Card Content -->
  <div class="p-1">
    <p class="text-[14px] text-black">{title}</p>
  </div>
</a>

<script>
  // Intersection Observer + Progressive Loading for Video Cards
  document.addEventListener('DOMContentLoaded', function() {
    // Configuration
    const CONFIG = {
      rootMargin: '50px', // Start loading 50px before entering viewport
      threshold: 0.1, // Trigger when 10% of video is visible
      maxConcurrentVideos: 4, // Maximum videos playing simultaneously
      playThreshold: 0.5, // Play when 50% visible
      noiseIntensity: 0.5, // TV noise intensity (0-1)
      noiseFPS: 24 // Frames per second for noise animation
    };

    let currentlyPlayingVideos = new Set<HTMLVideoElement>();
    let loadedVideos = new WeakSet();
    let noiseIntervals = new Map<HTMLCanvasElement, number>(); // Track noise animations

    // Utility: Draw TV static noise on canvas
    function drawTVNoise(canvas: HTMLCanvasElement) {
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      const width = canvas.width;
      const height = canvas.height;

      // Create ImageData for pixel manipulation
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      // Generate random grayscale noise
      for (let i = 0; i < data.length; i += 4) {
        const noise = Math.random() * 255 * CONFIG.noiseIntensity;
        data[i] = noise;     // Red
        data[i + 1] = noise; // Green
        data[i + 2] = noise; // Blue
        data[i + 3] = 255;   // Alpha (fully opaque)
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // Utility: Start TV noise animation
    function startTVNoise(canvas: HTMLCanvasElement) {
      // Stop any existing animation
      const existingInterval = noiseIntervals.get(canvas);
      if (existingInterval) {
        clearInterval(existingInterval);
      }

      // Set canvas size
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      // Start noise animation
      const interval = setInterval(() => {
        drawTVNoise(canvas);
      }, 1000 / CONFIG.noiseFPS) as unknown as number;

      noiseIntervals.set(canvas, interval);
    }

    // Utility: Stop TV noise and fade out canvas
    function stopTVNoise(canvas: HTMLCanvasElement) {
      // Stop animation
      const interval = noiseIntervals.get(canvas);
      if (interval) {
        clearInterval(interval);
        noiseIntervals.delete(canvas);
      }

      // Fade out canvas
      let opacity = 1;
      const fadeInterval = setInterval(() => {
        opacity -= 0.1;
        canvas.style.opacity = opacity.toString();

        if (opacity <= 0) {
          clearInterval(fadeInterval);
          canvas.style.display = 'none';
        }
      }, 50); // 500ms total fade
    }

    // Create intersection observers
    const loadObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          loadVideo(entry.target);
        }
      });
    }, {
      rootMargin: CONFIG.rootMargin,
      threshold: CONFIG.threshold
    });

    const playObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const videoCard = entry.target;
        const video = videoCard.querySelector('.video-element') as HTMLVideoElement;
        
        if (!video || !loadedVideos.has(video)) return;

        if (entry.isIntersecting && entry.intersectionRatio >= CONFIG.playThreshold) {
          playVideo(video, videoCard);
        } else {
          pauseVideo(video, videoCard);
        }
      });
    }, {
      threshold: CONFIG.playThreshold
    });

    // Load video function
    function loadVideo(videoCard: Element) {
      const video = videoCard.querySelector('.video-element') as HTMLVideoElement;
      const canvas = videoCard.querySelector('.video-loading-canvas') as HTMLCanvasElement;

      if (!video || loadedVideos.has(video)) return;

      // Start TV noise animation on canvas
      if (canvas) {
        startTVNoise(canvas);
      }

      // Set video source
      const dataSrc = video.getAttribute('data-src');
      if (dataSrc) {
        const source = video.querySelector('source');
        if (source) {
          source.src = dataSrc;
        }
        video.src = dataSrc;
      }

      // Handle video events
      video.addEventListener('canplay', () => {
        loadedVideos.add(video);

        // Stop TV noise and fade out canvas, then show video
        if (canvas) {
          stopTVNoise(canvas);
        }
        video.style.opacity = '1';

        // Start observing for play/pause
        playObserver.observe(videoCard);
      });

      video.addEventListener('error', () => {
        console.warn('Video failed to load:', dataSrc);
        // Stop noise but keep canvas visible as fallback on error
        if (canvas) {
          const interval = noiseIntervals.get(canvas);
          if (interval) {
            clearInterval(interval);
            noiseIntervals.delete(canvas);
          }
          canvas.style.opacity = '0.3';
        }
      });

      // Load the video
      video.load();
    }

    // Play video with concurrency control
    function playVideo(video: HTMLVideoElement, videoCard: Element) {
      // Check if we've reached max concurrent videos
      if (currentlyPlayingVideos.size >= CONFIG.maxConcurrentVideos) {
        // Pause the oldest playing video
        const oldestVideo = currentlyPlayingVideos.values().next().value;
        if (oldestVideo && oldestVideo !== video) {
          pauseVideoElement(oldestVideo);
        }
      }

      video.currentTime = 0; // Reset to beginning
      video.play().then(() => {
        currentlyPlayingVideos.add(video);
      }).catch((error) => {
        console.log('Autoplay failed:', error);
        // Handle autoplay restrictions (especially on mobile)
        showPlayButton(videoCard);
      });
    }

    // Pause video
    function pauseVideo(video: HTMLVideoElement, videoCard: Element) {
      pauseVideoElement(video);
    }

    function pauseVideoElement(video: HTMLVideoElement) {
      video.pause();
      currentlyPlayingVideos.delete(video);
    }

    // Show play button for manual interaction (fallback for autoplay restrictions)
    function showPlayButton(videoCard: Element) {
      const playButton = document.createElement('div');
      playButton.className = 'absolute inset-0 flex items-center justify-center bg-black/20 cursor-pointer z-10';
      playButton.innerHTML = `
        <div class="bg-white/95 backdrop-blur-sm rounded-full p-4 shadow-lg hover:scale-110 transition-transform">
          <svg class="w-8 h-8 text-gray-900" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </div>
      `;
      
      playButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const video = videoCard.querySelector('.video-element') as HTMLVideoElement;
        if (video) {
          video.play();
          playButton.remove();
        }
      });
      
      videoCard.querySelector('.relative')?.appendChild(playButton);
    }

    // Handle reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      console.log('Reduced motion detected, skipping video autoplay');
      return;
    }

    // Initialize observers for all video cards
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
      loadObserver.observe(card);
    });

    // Cleanup on page unload
     window.addEventListener('beforeunload', () => {
       currentlyPlayingVideos.forEach(video => {
         video.pause();
       });
     });

     // Handle visibility change (pause videos when tab is hidden)
     document.addEventListener('visibilitychange', () => {
       if (document.hidden) {
         currentlyPlayingVideos.forEach(video => {
           video.pause();
         });
       }
     });
  });
</script>

<style>
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>