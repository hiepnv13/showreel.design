---
export interface Props {
  title: string;
  author: string;
  thumbnail: string;
  videoUrl?: string;
  fullVideoUrl?: string;
  category?: string;
  slug?: string;
}

const { title, author, thumbnail, videoUrl, fullVideoUrl, category, slug } = Astro.props;
---

<a href={slug ? `/videos/${slug}` : '#'} class="video-card group cursor-pointer block" data-video-url={videoUrl}>
  <!-- Video Container -->
  <div class="relative overflow-hidden aspect-video bg-black">
    <!-- Pixelated Loading Preview (Low-res Thumbnail) -->
    <img
      src={thumbnail}
      alt={title}
      class="video-loading-preview absolute inset-0 w-full h-full"
      style="object-fit: none; image-rendering: pixelated; image-rendering: crisp-edges;"
    />

    <!-- Video Element -->
    {videoUrl ? (
      <video
        class="video-element w-full h-full object-cover opacity-0 transition-opacity duration-700"
        muted
        loop
        playsinline
        preload="none"
        data-src={videoUrl}
      >
        <source data-src={videoUrl} type="video/mp4" />
      </video>
    ) : (
      <!-- Fallback image if no video URL -->
      <img
        src={thumbnail}
        alt={title}
        class="w-full h-full object-cover"
        loading="lazy"
      />
    )}
    
    <!-- Video Overlay (subtle) -->
    <div class="absolute inset-0 bg-black/5 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
  </div>
  
  <!-- Card Content -->
  <div class="p-1">
    <p class="text-[14px] text-black">{title}</p>
  </div>
</a>

<script>
  // Intersection Observer + Progressive Loading for Video Cards
  document.addEventListener('DOMContentLoaded', function() {
    // Configuration
    const CONFIG = {
      rootMargin: '50px', // Start loading 50px before entering viewport
      threshold: 0.1, // Trigger when 10% of video is visible
      maxConcurrentVideos: 4, // Maximum videos playing simultaneously
      playThreshold: 0.5 // Play when 50% visible
    };

    let currentlyPlayingVideos = new Set<HTMLVideoElement>();
    let loadedVideos = new WeakSet();

    // Create intersection observers
    const loadObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          loadVideo(entry.target);
        }
      });
    }, {
      rootMargin: CONFIG.rootMargin,
      threshold: CONFIG.threshold
    });

    const playObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const videoCard = entry.target;
        const video = videoCard.querySelector('.video-element') as HTMLVideoElement;
        
        if (!video || !loadedVideos.has(video)) return;

        if (entry.isIntersecting && entry.intersectionRatio >= CONFIG.playThreshold) {
          playVideo(video, videoCard);
        } else {
          pauseVideo(video, videoCard);
        }
      });
    }, {
      threshold: CONFIG.playThreshold
    });

    // Load video function
    function loadVideo(videoCard: Element) {
      const video = videoCard.querySelector('.video-element') as HTMLVideoElement;
      const pixelPreview = videoCard.querySelector('.video-loading-preview') as HTMLImageElement;

      if (!video || loadedVideos.has(video)) return;

      // Pixelated preview is already showing (from HTML)
      // No need to start animation, it's pure CSS

      // Set video source
      const dataSrc = video.getAttribute('data-src');
      if (dataSrc) {
        const source = video.querySelector('source');
        if (source) {
          source.src = dataSrc;
        }
        video.src = dataSrc;
      }

      // Handle video events
      video.addEventListener('canplay', () => {
        loadedVideos.add(video);

        // Fade out pixelated preview
        if (pixelPreview) {
          pixelPreview.style.transition = 'opacity 500ms ease-out';
          pixelPreview.style.opacity = '0';

          // Remove from DOM after fade
          setTimeout(() => {
            pixelPreview.style.display = 'none';
          }, 500);
        }

        // Show video
        video.style.opacity = '1';

        // Start observing for play/pause
        playObserver.observe(videoCard);
      });

      video.addEventListener('error', () => {
        console.warn('Video failed to load:', dataSrc);
        // Keep pixelated preview visible on error (already there)
      });

      // Load the video
      video.load();
    }

    // Play video with concurrency control
    function playVideo(video: HTMLVideoElement, videoCard: Element) {
      // Check if we've reached max concurrent videos
      if (currentlyPlayingVideos.size >= CONFIG.maxConcurrentVideos) {
        // Pause the oldest playing video
        const oldestVideo = currentlyPlayingVideos.values().next().value;
        if (oldestVideo && oldestVideo !== video) {
          pauseVideoElement(oldestVideo);
        }
      }

      video.currentTime = 0; // Reset to beginning
      video.play().then(() => {
        currentlyPlayingVideos.add(video);
      }).catch((error) => {
        console.log('Autoplay failed:', error);
        // Handle autoplay restrictions (especially on mobile)
        showPlayButton(videoCard);
      });
    }

    // Pause video
    function pauseVideo(video: HTMLVideoElement, videoCard: Element) {
      pauseVideoElement(video);
    }

    function pauseVideoElement(video: HTMLVideoElement) {
      video.pause();
      currentlyPlayingVideos.delete(video);
    }

    // Show play button for manual interaction (fallback for autoplay restrictions)
    function showPlayButton(videoCard: Element) {
      const playButton = document.createElement('div');
      playButton.className = 'absolute inset-0 flex items-center justify-center bg-black/20 cursor-pointer z-10';
      playButton.innerHTML = `
        <div class="bg-white/95 backdrop-blur-sm rounded-full p-4 shadow-lg hover:scale-110 transition-transform">
          <svg class="w-8 h-8 text-gray-900" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </div>
      `;
      
      playButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const video = videoCard.querySelector('.video-element') as HTMLVideoElement;
        if (video) {
          video.play();
          playButton.remove();
        }
      });
      
      videoCard.querySelector('.relative')?.appendChild(playButton);
    }

    // Handle reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      console.log('Reduced motion detected, skipping video autoplay');
      return;
    }

    // Initialize observers for all video cards
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
      loadObserver.observe(card);
    });

    // Cleanup on page unload
     window.addEventListener('beforeunload', () => {
       currentlyPlayingVideos.forEach(video => {
         video.pause();
       });
     });

     // Handle visibility change (pause videos when tab is hidden)
     document.addEventListener('visibilitychange', () => {
       if (document.hidden) {
         currentlyPlayingVideos.forEach(video => {
           video.pause();
         });
       }
     });
  });
</script>

<style>
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>